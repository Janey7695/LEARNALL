### 一、芯片特点

>1. 采用单总线的接口方式 与微处理器连接时仅需要一条口线即可实现微处理器与 DS18B20 的双向通讯。单总线具有经济性好，抗干扰能力强，适合于恶劣环境的现场温度测量，使用方便等优点，使用户可轻松地组建传感器网络，为测量系统的构建引入全新概念。
2. 测量温度范围宽，测量精度高 DS18B20 的测量范围为 -55 ℃ ~ +125 ℃; 在-10~+ 85°C范围内，精度为±0.5°C。
3. 在使用中不需要任何外部元件
4. 持多点组网功能 多个 DS18B20 可以并联在惟一的单线上，实现多点测温。
5. 供电方式灵活 DS18B20 可以通过内部寄生电路从数据线上获取电源。因此，当数据线上的时序满足一定的要求时，可以不接外部电源，从而使系统结构更趋简单，可靠性更高。
6. 测量参数可配置 DS18B20 的测量分辨率可通过程序设定 9~12 位。
7. 负压特性电源极性接反时，温度计不会因发热而烧毁，但不能正常工作。
>8. 掉电保护功能 DS18B20 内部含有 EEPROM ，在系统掉电以后，它仍可保存分辨率及报警温度的设定值。

DS18B20 具有体积更小、适用电压更宽、更经济、可选更小的封装方式，更宽的电压适用范围，适合于构建自己的经济的测温系统。仅有三管脚GND接地,DQ为数据输入输出，VDD外接电源管脚（在寄生电源接线方式时接地）。[![](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_2d96a1d88c307b2575e817151af1432e.jpg)](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_2d96a1d88c307b2575e817151af1432e.jpg)
### 二、内部结构
主要由4部分组成：64位ROM、温度传感器、配置寄存器、非挥发的温度报警触发器。
[![](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_a870ddb50ed1b24dd3544cef83b83e29.jpg)](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_a870ddb50ed1b24dd3544cef83b83e29.jpg)  

其中，ROM中的64位序列号是出厂光刻好的了，它可以看作是DS18B20的地址序列码，每个ds18b20都有自己独特的序列码，因此一条总线上可以挂接多个ds18b20，主机可以通过这些序列码来进行辨认。  


|温度低位|温度高位|高温阈值TH|低温阈值TL|配置|保留|保留|保留|CRC校验|
|---|---|---|---|---|---|---|---|---|
|0|1|2|3|4|5|6|7|8|

LSB(0)->MSB(8)

高速暂存器里面有9个字节，最低的2个字节分别表示温度的低八位与高八位，第三、第四个字节表示高温阈值与低温阈值，第五个字节是配置寄存器，第六七八字节是保留字节，第九字节是8位CRC校验码。

64位光刻ROM：

|8-BIT CRC|48-BIT 序列号|8-BIT 系列码|
|---|---|---|
|MSB->LSB|MSB->LSB|MSB->LSB|

### 三、测温原理
DS18b20是这样测温的：用一个高温度系数的振荡器确定一个门周期，内部计数器在这个门周期内对一个低温度系数的振荡器的脉冲进行计数来得到温度值。计数器被预置到对应-55°c的一个值上，如果计数器在门周期结束前到达0，则温度寄存器（同样被预置到-55°c
）的值增加，表明所测温度大于-55°c。

同时，计数器被复位到一个值，这个值由斜坡式累加器电路决定，斜坡式累加器电路用来补偿感温振荡器的抛物线特性。然后计数器又开始计数直到0，如果门周期仍未结束，将重复这一个步骤。

ds18b20内部对此计算的结果可以提供0.5°c的分辨力。温度以16bit带符号位扩展的二进制补码形式读出，下表给出了温度值与输出温度的关系：
[![](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_8d0487ad3eece8067619a2afaca0f077.jpg)](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_8d0487ad3eece8067619a2afaca0f077.jpg)

注意ds18b20内部温度表示值为1/2°cLSB，如下所示9bit格式：

[![](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_90bb9f7f6a31cf861a941d15309796c1.jpg)](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_90bb9f7f6a31cf861a941d15309796c1.jpg)

最高有效（符号）位被*复制充满*存储器中两字节温度寄存器的高MSB位。如果得到的温度是负的，则把输出的16bit数据先取反码，然后再读数，可视化操作时再人工加上`-`号。

### 三、各种操作

#### 1.初始化
通过单线总线的所有执行（处理）都从一个初始化序列开始。初始化序列包括一个由总线控制器发出的复位脉冲和跟其后由从机发出的存在脉冲。存在脉冲让总线控制器知道DS18B20在总线上且已经做好操作准备了。
[![](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_ff2693f303bd1ec8f2a0fd145958e3fd.jpg)](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_ff2693f303bd1ec8f2a0fd145958e3fd.jpg)

如上图，初始化时：
1. 数据线电平拉高设置为1
2. 一小段延时，这段延时不是很严格，但是尽量短
3. 数据线电平拉低设置为0
4. 延时480us-960us
5. 数据线电平重新拉高设置为1
6. 延时等待，如果初始化成功，会在15-60us内返回一个由ds18b20产生的0低电平，根据该状态可以确定它的存在，但不应进行无限等待，因此需要设置相应时间否则程序进入死循环
7. 如果cpu读到0后还要做延时，应该从发出高电平开始，至少要有480us的延时
8. 数据线电平拉高设置为1，初始化结束
代码如下：
~~~c
uchar Ds18b20Init()
{
    uchar i=0;
    DSPORT=0;
	i=70;
	while(i--); //642us
	DSPORT=1;
	i=0;
	while(DSPORT)
	{
	    delay1ms(1);
		i++;
		if(i>5)
		{
		    return 0;
		}
	}
	return 1;
}
~~~

#### 2. 读/写操作
[![](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_47e3de46def8db569cc50d8dea2c21f5.jpg)](http://112.124.31.67/wp-content/uploads/2020/07/wp_editor_md_47e3de46def8db569cc50d8dea2c21f5.jpg)

如上图，写0/1操作为：
1. 数据线电平置0
2. 延时15us
3. 按照从低到高的顺序发生字节（__一次仅发生一位！__）
4. 延时45us
5. 数据线拉回高电平
6. 重复1-5的步骤，直到要发送的字节全部发送完
7. 最后将数据线拉高为1
代码如下：
~~~c
void Ds18b20WriteByte(uchar dat)
{
    uchar i,j;
	for(j=0;j<8;j++)
	{
	    DSPORT=0;
		i++;
		DSPORT=dat&0x01;
		i=6;
		while(i--);//68us
		DSPORT=1;
		dat>>=1;
	}
}
~~~

读0/1操作如下：
1. 数据线拉高为1
2. 延时2us （其实1，2步可以不做，前提时在读之前数据线电平是1）
3. 数据线拉低为0
4. 延时15us
5. 电平拉高为1
6. 延时15us
7. 读取数据线状态得到一个状态位，并进行数据处理（即一次会获取一位，如果要读一个字节，需要这样接收8次）
8. 延时30us
9. 重复1-8直到读完

代码如下：
~~~c
uchar Ds18b20ReadByte()
{
    uint i,j;
	uchar bi,byte;
	for(j=8;j>0;j--)
	{
	    DSPORT=0;
		i++;
		DSPORT=1;
		i++;
		i++;
		bi=DSPORT;
		byte=(byte>>1)|(bi<<7);
		i=4;
		while(i--);//>45us 
	}
	return byte;
}
~~~

### 四、启动工作，温度转换读取

编写了读写与初始化函数后，我们就可以向ds18b20传输指令，命令其开始工作，并通过指令读取温度信息，开始温度转换流程如下：
1. 初始化
2. 延时一毫秒
3. 总线上只有一个ds18b20的情况下可以跳过ROM匹配，我们向ds18b20输入CC指令，跳过rom匹配
4. 写入44指令，让其开始温度转换工作（此时温度信息存储在高速暂存器里面）
代码如下：
~~~c
void Ds18b20ChangeTemp()
{
    Ds18b20Init();
	delay1ms(1);
	Ds18b20WriteByte(0xcc);
	Ds18b20WriteByte(0x44);// begin to change temp 
}
~~~

__注意，温度转换大约需要750ms的时间__

然后进行温度读取：
1. 进行初始化
2. 延时1ms
3. 传入命令CC，不需要进行ROM匹配
4. 传入命令BE,开始读取暂存器里面的温度数据
5. 用int型（89C51是8位的处理器，int即2个字节，16位）的变量来接收温度数据（先接收低八位，再接收高八位）
代码如下：
~~~c
void Ds18b20ReadTempCom()
{
 	Ds18b20Init();
	delay1ms(1);
	Ds18b20WriteByte(0xcc);
	Ds18b20WriteByte(0xbe);
}
~~~
上面的代码并没有提及第5步，因为第5步在温度读取的总的数据处理环节出现：
~~~c
int Ds18b20ReadTemp()
{
    int temp=0;
    uchar tmh,tml;
    Ds18b20ChangeTemp();
	Ds18b20ReadTempCom();
	tml=Ds18b20ReadByte();
	tmh=Ds18b20ReadByte();
	temp=tmh;
	temp<<=8;
	temp|=tml;
	return temp;
}
~~~

### 五、对得到的temp的处理
首先要区分正负，判断temp的符号，如果是正的，直接套用格式进行换算，将16位的temp转换成人类可读的数字float型tp，`tp=temp*0.0625*100+0.5`,然后使用一个数组`num[]`来分别存放从符号到0.01位的数字。如果是负的，首先记录`num[0]='-'`，然后对temp求反`temp=~temp`，然后用相同的公式转换`tp=temp*0.0625*100+0.5`，并存入`num[]。
~~~c
void ChangeTemptoTp(int temp)
{
	float tp;
	if(temp<0)
	{
		num[0]='-';
		temp=~temp;
		tp=temp;//类型转换，因为后面有除法
		temp=tp*0.0625*100+0.5;
	}
	else
	{
		num[0]='+';
		tp=temp;
		temp=tp*0.0625*100+0.5;
	}
	num[1]=temp/10000;//取百位数字
	num[2]=temp%10000/1000;//取十位数字
	num[3]=temp%10000%1000/100;//取个位数字
	num[4]=temp%100/10;//取0.1位
	num[5]=temp%100%10;//取0.01位
}
~~~

然后通过显示num就可以显示出温度，可以结合lcd或数码管等进行显示。
